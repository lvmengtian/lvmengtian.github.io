---
title: Spring
createTime: 2025/11/28 17:10:04
permalink: /java-guide/ysb3pgbj/
---
## Spring如何解决循环依赖
> “在Spring的世界里，Bean就像一群需要互相协作的同事。但有时会出现一种尴尬的局面：
> -   A同事说：‘不行，我得等B把方案给我，我才能开始工作。’
> -   B同事说：‘不行，我得等A把资料给我，我才能动工。’
> 
> 这就形成了 **‘循环依赖’**。在Spring中，如果两个Bean（如A和B）互相依赖（A依赖B，B也依赖A），Spring是如何处理，而不让整个应用启动失败的呢？今天小毛带你深入三级缓存，看看Spring的神来之笔。”

### 🤔 **循环依赖会报错吗？**

**结论是：不一定，分情况讨论。**

1.  **大部分情况下，不报错**：Spring框架**内置了一套成熟的机制（三级缓存）** 来解决常见的循环依赖问题。
2.  **特定情况下，会报错**：如果Spring无法解决，它会抛出 `BeanCurrentlyInCreationException` 异常。

**关键在于：<font color="red">依赖的方式和Bean的作用域。</font>**

### 📚 **Spring的解决方案：三级缓存架构**

我们先来理解Spring为解决循环依赖准备的“三级仓库”：

| 缓存名称                  | 源码中名称               | 存储内容                                      | 作用                                                         |
| :------------------------ | :----------------------- | :-------------------------------------------- | :----------------------------------------------------------- |
| **一级缓存 (单例池)**     | `singletonObjects`       | **完整的单例Bean**                            | 存放已经完全初始化好的Bean，对外提供使用。                     |
| **二级缓存 (早期曝光)**   | `earlySingletonObjects`  | **早期的Bean对象** (尚未填充属性)             | 存放刚从三级缓存中取出的对象，避免代理对象被重复创建。         |
| **三级缓存 (对象工厂)**   | `singletonFactories`     | **ObjectFactory** (用于生成早期对象的工厂)    | **解决循环依赖的关键**，存放一个能生成早期Bean引用（可能是代理对象）的工厂。 |

### 🔍 **解决流程详解**

让我们以经典的属性注入循环依赖 `A -> B -> A` 为例，来看Spring如何通过三级缓存破解这个“死结”：
![](/images/spring_third_cache.png)

**流程核心要点：**
1.  **破局点在于“实例化”和“依赖注入”的分离**：Spring先把Bean的“空壳”（对象实例）创建出来，并不等它完全填满属性，就提前把这个“空壳”的引用暴露出去。
2.  **三级缓存是核心**：它存放的是一个工厂。这个工厂的最大作用是**在需要的时候能够返回一个早期引用，并且能处理AOP代理问题**。如果直接把这个早期引用放在二级缓存，那么遇到AOP时，就无法保证返回的是同一个代理对象。
3.  **升级缓存**：当某个Bean的早期引用被其他Bean依赖后，它会被从三级缓存升级到二级缓存。

### 🌰 **无法解决的循环依赖场景**

Spring不是万能的，在以下情况下，循环依赖会**报错**：

1.  **构造器循环依赖**：
    ```java
    @Service
    public class A {
        private B b;
        public A(B b) { // 通过构造器注入B
            this.b = b;
        }
    }
    @Service
    public class B {
        private A a;
        public B(A a) { // 通过构造器注入A
            this.a = a;
        }
    }
    ```
    **原因**：在实例化A的时候，就需要一个完整的B；而实例化B又需要一个完整的A。双方连“空壳”都创建不出来，死锁无法破解。

2.  **Prototype作用域的Bean循环依赖**：
    **原因**：Spring不缓存Prototype类型的Bean，所以无法提供早期暴露的引用。

3.  **@Async方法导致的循环依赖**等特殊情况。
