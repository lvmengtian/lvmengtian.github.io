---
title: Java 锁
createTime: 2025/11/29 16:13:40
permalink: /java-guide/millg80j/
---
## Synchronized的实现原理
> “大家都知道 `synchronized` 是Java里的‘同步锁’，用它包裹的代码能保证线程安全。但你有没有想过，这个‘锁’到底长什么样？它被存在了哪里？为什么有的锁效率高，有的锁效率低？

### Synchronized的三种用法

首先，我们要明确`synchronized`可以锁在哪里，这是理解其原理的基础。

| 用法 | 示例 | 锁的对象 |
| :--- | :--- | :--- |
| **实例方法** | `public synchronized void method()` | **当前实例对象** (`this`) |
| **静态方法** | `public static synchronized void method()` | **当前类的Class对象** (如 `MyClass.class`) |
| **代码块** | `synchronized(obj) { ... }` | **括号里配置的对象** (`obj`) |

**核心概念：** 无论哪种用法，synchronized锁住的都是一个**Java对象**。

### JVM中的实现原理

这是内容的精髓，我们必须分层解析。

#### 层面一：字节码层面 —— `monitorenter` 与 `monitorexit`

我们可以通过一个清晰的流程图，来看当线程进入和退出同步块时，在字节码层面和JVM层面发生了什么：
![](/images/synchronized_flow1.png)


当我们编译一个`synchronized`代码块时，编译器会在同步代码块的前后分别生成 `monitorenter` 和 `monitorexit` 指令。

- `monitorenter`：尝试**进入**并持有该对象的监视器。
- `monitorexit`：**释放**该对象的监视器。

**这两条指令的背后，是JVM与操作系统协同工作的结果。**

#### 层面二：对象头与Mark Word (锁的物理载体)

**锁实际上是存在每个Java对象的对象头里的。** 对象头主要包括两部分：

1.  **Mark Word**：存储对象自身的运行时数据，如**哈希码、GC分代年龄、锁状态标志**等。这是实现锁的关键！
2.  **Klass Pointer**：对象指向它的类型元数据的指针。

为了更直观地理解Mark Word如何作为锁信息的载体，下图展示了32位JVM下Mark Word在不同锁状态下的内存布局：

| 锁状态 | 25 bits | 4 bits | 1 bit | 2 bits | **对应“形态”说明** |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **无锁 (可偏向)** | **`identity_hashcode`** | **`age`** | **`biased_lock=0`** | **`lock=01`** | 这是你给出的结构。此时对象未被锁定，但**允许偏向**。如果计算过hashCode，则25位用于存储。 |
| **偏向锁** | **`thread:23` + `epoch:2`** | **`age`** | **`biased_lock=1`** | **`lock=01`** | **形态改变！** 当有线程偏向时，23位存储线程ID，2位存储epoch，**原有的hashCode存储被覆盖**。 |
| **轻量级锁** | **`pointer_to_lock_record:30`** | | | **`lock=00`** | **形态彻底改变！** 30位指向线程栈帧中的锁记录指针。 |
| **重量级锁** | **`pointer_to_monitor:30`** | | | **`lock=10`** | **形态彻底改变！** 30位指向互斥量（monitor）的指针。 |
| **GC标记** | (已忽略) | | | **`lock=11`** | 被垃圾回收器标记时使用。 |

#### 层面三：锁的升级与优化

为了提高性能，JVM中的锁会从低开销到高开销进行升级。这个过程是不可逆的，目的就是为了减少直接使用重量级锁带来的性能损耗。

1.  **偏向锁**：
    - **目标**：解决在**没有竞争**情况下，同一个线程重复获取锁的性能开销。
    - **做法**：当第一个线程访问同步块时，会在Mark Word里记录自己的线程ID。以后该线程再进入和退出同步块时，不需要进行CAS操作来加锁和解锁，只需简单检查一下Mark Word里是否存储着自己的线程ID。

2.  **轻量级锁**：
    - **场景**：当有**轻微竞争**，另一个线程来尝试获取锁。
    - **做法**：JVM会在当前线程的栈帧中创建一个名为**锁记录**的空间，然后将对象头的Mark Word复制过去。然后，线程尝试用**CAS操作**将对象头的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁；如果失败，表示有其他线程竞争，则**膨胀为重量级锁**。

3.  **重量级锁**：
    - **场景**：**竞争激烈**，轻量级锁自旋一定次数后依然无法获取锁。
    - **做法**：向操作系统申请**互斥量**。此时，未获取到锁的线程会被**挂起**，进入阻塞状态，等待操作系统调度唤醒。这个过程的成本最高，涉及到用户态到内核态的切换。

### 锁对比

| 锁类型 | 优点 | 缺点 | 适用场景 |
| :--- | :--- | :--- | :--- |
| **偏向锁** | 加锁解锁无需额外消耗 | 如果存在锁竞争，会带来额外的撤销消耗 | 只有一个线程访问同步块 |
| **轻量级锁** | 竞争的线程不会阻塞，响应快 | 始终得不到锁的线程，会自旋消耗CPU | 追求响应时间，同步块执行非常快 |
| **重量级锁** | 竞争激烈时，自旋的CPU消耗少 | 线程阻塞，响应时间缓慢 | 追求吞吐量，同步块执行时间较长 |

### 总结
> 关于synchronized的原理，从三个层面理解：
> 1. 字节码层面：依赖于monitorenter和monitorexit指令。
> 2. JVM层面：锁的具体信息存储在对象头的Mark Word中。
> 3. 锁优化层面：为了平衡性能，JVM设计了偏向锁、轻量级锁、重量级锁的升级过程，根据竞争激烈程度动态切换。”
> 
> “它的保证的可见性和有序性，是通过在解锁时必须将工作内存的变量刷回主内存，以及‘一个变量在同一时刻只允许一条线程对其进行lock操作’这条规则来实现的。”

## synchronized VS ReentrantLock 如何抉择
> “在JDK1.6之前，ReentrantLock在性能上对synchronized是碾压性的优势。但1.6之后，synchronized被重写了底层，加入了偏向锁、轻量级锁等优化，**两者在性能上已相差无几**。所以现在的抉择就不再是‘谁更快’，而是 **‘谁更能解决我的实际问题’** 。

### 核心差异对比

| 特性维度 | 🗝️ synchronized (JVM内置锁) | 🔌 ReentrantLock (API层面的锁) |
| :--- | :--- | :--- |
| **获取与释放** | **自动管理**。JVM负责在代码块入口和出口加锁、释放锁，不会遗忘。 | **手动管理**。必须显式调用 `lock()` 和 `unlock()`，易遗忘，需在 `finally` 中释放。 |
| **可中断性** | **不可中断**。线程若争抢不到锁，会一直阻塞，无法响应中断。 | **可中断**。提供了 `lockInterruptibly()` 方法，在等待锁时可以响应线程中断。 |
| **公平性** | **仅支持非公平锁**。 | **支持两者**。构造函数可传入 `true` 来创建公平锁，防止线程饥饿。 |
| **超时机制** | **不支持**。 | **支持**。`tryLock(long timeout, TimeUnit unit)` 可尝试获取锁，超时则放弃。 |
| **绑定条件** | **单一等待队列**。`wait()`/`notify()`/`notifyAll()` 随机唤醒。 | **多个Condition**。一个锁可以绑定多个条件队列，实现精确唤醒。 |
| **锁粒度** | 方法或代码块。 | 更灵活，锁的获取和释放可以跨越方法。 |
| **性能趋势** | JDK1.6后优化很好，在**低至中度竞争**下性能极佳。 | 在高竞争环境下，仍能保持稳定，提供了更丰富的**避免竞争**的手段。 |

### 核心优势场景深度解析

#### 1. 何时优先选择synchronized？

-   **场景一：追求开发效率与可靠性**
    -   **理由**：语法简洁，自动释放，无需担心因异常导致锁无法释放的问题。这是它**最核心的优势**。
    -   **代码对比**：
        ```java
        // synchronized: 简洁，可靠
        public synchronized void add() {
            // ... 业务逻辑
        }

        // ReentrantLock: 繁琐，需手动处理
        private ReentrantLock lock = new ReentrantLock();
        public void add() {
            lock.lock(); // 如果这里发生异常，锁还沒获取到
            try {
                // ... 业务逻辑
            } finally {
                lock.unlock(); // 必须放在finally块，确保锁释放
            }
        }
        ```

-   **场景二：绝大多数并发场景**
    -   **理由**：在大部分业务系统中，锁的竞争并不激烈。synchronized经过优化后，在这种情况下性能非常好，且JVM会自动进行锁升级/降级，无需开发者关心。

#### 2. 何时应考虑 ReentrantLock？

-   **场景一：需要应对“死等”风险 —— 可中断与超时**
    -   **案例**：一个转账服务，需要同时获取A锁和B锁。如果线程T1持有A等B，T2持有B等A，形成死锁。
    -   **synchronized方案**：无解，只能重启。
    -   **ReentrantLock方案**：使用 `tryLock` 进行尝试。
        ```java
        if (lockA.tryLock(1, TimeUnit.SECONDS)) { // 尝试获取锁A，等1秒
            try {
                if (lockB.tryLock(1, TimeUnit.SECONDS)) { // 尝试获取锁B，等1秒
                    try {
                        // ... 执行转账业务
                    } finally {
                        lockB.unlock();
                    }
                }
            } finally {
                lockA.unlock();
            }
        } else {
            // 记录日志，执行补偿逻辑，不会死锁
        }
        ```

-   **场景二：实现“先来后到” —— 公平锁**
    -   **案例**：一个票务系统，希望先请求的用户先买到票，避免某些用户一直抢不到（线程饥饿）。
    -   **解决方案**：使用 `new ReentrantLock(true)`。

-   **场景三：实现“分组唤醒” —— 条件变量 (Condition)**
    -   **经典案例：生产者-消费者模型**。我们希望生产者只唤醒消费者，消费者只唤醒生产者，而不是把所有等待线程都唤醒。
    -   **synchronized方案**：使用 `Object.wait()` 和 `Object.notifyAll()`，但 `notifyAll()` 会唤醒所有等待的生产者和消费者，效率低。
    -   **ReentrantLock方案**：使用两个Condition。
        ```java
        private ReentrantLock lock = new ReentrantLock();
        private Condition notFull = lock.newCondition();  // 队列未满条件
        private Condition notEmpty = lock.newCondition(); // 队列非空条件

        // 生产者
        public void put(Object item) throws InterruptedException {
            lock.lock();
            try {
                while (queue.isFull()) {
                    notFull.await(); // 在“未满”条件上等待
                }
                // ... 生产数据
                notEmpty.signal(); // 精准唤醒一个在“非空”条件上等待的消费者
            } finally {
                lock.unlock();
            }
        }
        // 消费者同理，使用notEmpty.await()和notFull.signal()
        ```

### 总结
> “**优先使用synchronized**。因为在JDK1.6优化后，它的性能已经不差，而且语法简单、由JVM自动管理，能有效减少编码错误。只有在需要synchronized无法提供的**高级功能**时，我才会考虑使用ReentrantLock，比如：
> 1.  **需要尝试获取锁**，用于解决死锁或苛刻的超时控制。
> 2.  **需要公平锁**，来处理线程饥饿问题。
> 3.  **需要可中断的锁**，让线程在等待时能响应外部中断。
> 4.  **需要绑定多个条件变量**，来实现线程间的精确通知，比如经典的生产者-消费者模型。”

## volatile是线程安全的么
> “很多同学一看到 `volatile` 和‘线程’、‘变量’联系在一起，就下意识地认为它是线程安全的。**这是一个危险的误解！**
> 今天，我们就一起来彻底拆解 `volatile`：它能做什么，不能做什么，以及它的底层实现原理。”

### volatile是线程安全的么
先说结论：**volatile不是线程安全的**

首先，我们必须明确一个核心结论：**`volatile` 解决的是变量在多个线程间的‘可见性’问题，但它不保证复合操作的‘原子性’。**

为了更直观地理解它在并发安全中的独特定位，可以参考下面的“并发安全三要素”剖析图：
![](/images/juc_safe_3.png)

从上图可以清晰地看到，`volatile` 只解决了三要素中的“可见性”和部分“有序性”，但最关键的“原子性”它无法保证。因此，它本身**不是线程安全**的。

### 原理探秘：JMM与内存屏障

`volatile` 的实现原理，深植于 **Java内存模型** 之中。

#### 1. 可见性原理：绕过工作内存

-   **普通变量**：线程A从主内存读取变量到自己的工作内存，修改后，不一定立即写回主内存。线程B此时读取的可能是主内存中的旧值。
-   **volatile变量**：
    -   **写操作**：当写一个 `volatile` 变量时，JMM会**立即**将该线程对应的工作内存中的新值**强制刷新到主内存**中。
    -   **读操作**：当读一个 `volatile` 变量时，JMM会使该线程的工作内存中的缓存失效，从而**必须从主内存中重新读取**最新值。

#### 2. 有序性原理：内存屏障

为了实现可见性和禁止指令重排序，JVM在编译器和CPU级别使用了 **“内存屏障”**。你可以把内存屏障理解为一堵墙，告诉编译器和CPU：“屏障前的指令和屏障后的指令，不能乱序执行”。

对于 `volatile` 变量，JVM会在其读写操作前后插入特定的内存屏障：

| 场景 | 插入的屏障 | 作用 |
| :--- | :--- | :--- |
| **volatile 写** | StoreStore + StoreLoad | 确保**写前**的所有普通写操作都对其他线程可见；**写后**的指令不会被重排到写之前。 |
| **volatile 读** | LoadLoad + LoadStore | 确保**读后**的所有读/写操作都不会被重排到读之前。 |

正是这些内存屏障，保证了 `volatile` 的可见性和有序性。

### volatile的正确使用姿势

既然 `volatile` 不保证原子性，那它有什么用？它最适合用于**状态标志位**。

**✅ 正确示例：优雅地停止线程**
```java
public class MyThread extends Thread {
    // 使用volatile作为状态标志
    private volatile boolean stopped = false;

    public void run() {
        while (!stopped) { // 读volatile变量
            // ... 执行任务
        }
    }
    public void stopThread() {
        stopped = true; // 写volatile变量
    }
}
```
**为什么这是线程安全的？**
因为对 `stopped` 的操作是**单一的赋值操作**，本身具有原子性。`volatile` 在这里保证了当主线程调用 `stopThread()` 后，工作线程能**立即看到** `stopped` 变为 `true`，从而及时退出循环。

**❌ 错误示例：尝试用volatile做计数器**
```java
public class Counter {
    private volatile int count = 0;
    public void increment() {
        count++; // 这是一个“读-改-写”的复合操作，不是原子操作！
    }
    public int getCount() { return count; }
}
```
**为什么这是不安全的？**
`count++` 实际上包含三个步骤：
1.  读取 `count` 的当前值。
2.  将值加1。
3.  将新值写回 `count`。

假设两个线程同时执行到步骤1，它们可能读到相同的值，比如都是5，然后各自加1后写回，最终结果是6，而不是预期的7。`volatile` 在这里只能保证它们读到的都是最新值，但无法阻止这两个线程的步骤1-2-3交织在一起执行。

### 总结
> 关于volatile：
> 1.  **它不是线程安全的**。它只能保证**可见性**和**有序性**，但无法保证复合操作的**原子性**。
> 2.  它的底层原理是通过**内存屏障**实现的。在写操作时强制刷盘，在读操作时使缓存失效，并禁止指令重排序。
> 3.  它最经典的适用场景是作为一个**状态标志位**，比如安全地停止一个线程。但如果涉及到多个线程对同一个变量进行‘读-改-写’（如i++），则必须使用`synchronized`或`AtomicXXX`类。”
