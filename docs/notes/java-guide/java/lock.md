---
title: Java 锁
createTime: 2025/11/29 16:13:40
permalink: /java-guide/millg80j/
---
## Synchronized的实现原理
> “大家都知道 `synchronized` 是Java里的‘同步锁’，用它包裹的代码能保证线程安全。但你有没有想过，这个‘锁’到底长什么样？它被存在了哪里？为什么有的锁效率高，有的锁效率低？

### Synchronized的三种用法

首先，我们要明确`synchronized`可以锁在哪里，这是理解其原理的基础。

| 用法 | 示例 | 锁的对象 |
| :--- | :--- | :--- |
| **实例方法** | `public synchronized void method()` | **当前实例对象** (`this`) |
| **静态方法** | `public static synchronized void method()` | **当前类的Class对象** (如 `MyClass.class`) |
| **代码块** | `synchronized(obj) { ... }` | **括号里配置的对象** (`obj`) |

**核心概念：** 无论哪种用法，synchronized锁住的都是一个**Java对象**。

### JVM中的实现原理

这是内容的精髓，我们必须分层解析。

#### 层面一：字节码层面 —— `monitorenter` 与 `monitorexit`

我们可以通过一个清晰的流程图，来看当线程进入和退出同步块时，在字节码层面和JVM层面发生了什么：
![](/images/synchronized_flow1.png)


当我们编译一个`synchronized`代码块时，编译器会在同步代码块的前后分别生成 `monitorenter` 和 `monitorexit` 指令。

- `monitorenter`：尝试**进入**并持有该对象的监视器。
- `monitorexit`：**释放**该对象的监视器。

**这两条指令的背后，是JVM与操作系统协同工作的结果。**

#### 层面二：对象头与Mark Word (锁的物理载体)

**锁实际上是存在每个Java对象的对象头里的。** 对象头主要包括两部分：

1.  **Mark Word**：存储对象自身的运行时数据，如**哈希码、GC分代年龄、锁状态标志**等。这是实现锁的关键！
2.  **Klass Pointer**：对象指向它的类型元数据的指针。

为了更直观地理解Mark Word如何作为锁信息的载体，下图展示了32位JVM下Mark Word在不同锁状态下的内存布局：

| 锁状态 | 25 bits | 4 bits | 1 bit | 2 bits | **对应“形态”说明** |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **无锁 (可偏向)** | **`identity_hashcode`** | **`age`** | **`biased_lock=0`** | **`lock=01`** | 这是你给出的结构。此时对象未被锁定，但**允许偏向**。如果计算过hashCode，则25位用于存储。 |
| **偏向锁** | **`thread:23` + `epoch:2`** | **`age`** | **`biased_lock=1`** | **`lock=01`** | **形态改变！** 当有线程偏向时，23位存储线程ID，2位存储epoch，**原有的hashCode存储被覆盖**。 |
| **轻量级锁** | **`pointer_to_lock_record:30`** | | | **`lock=00`** | **形态彻底改变！** 30位指向线程栈帧中的锁记录指针。 |
| **重量级锁** | **`pointer_to_monitor:30`** | | | **`lock=10`** | **形态彻底改变！** 30位指向互斥量（monitor）的指针。 |
| **GC标记** | (已忽略) | | | **`lock=11`** | 被垃圾回收器标记时使用。 |

#### 层面三：锁的升级与优化

为了提高性能，JVM中的锁会从低开销到高开销进行升级。这个过程是不可逆的，目的就是为了减少直接使用重量级锁带来的性能损耗。

1.  **偏向锁**：
    - **目标**：解决在**没有竞争**情况下，同一个线程重复获取锁的性能开销。
    - **做法**：当第一个线程访问同步块时，会在Mark Word里记录自己的线程ID。以后该线程再进入和退出同步块时，不需要进行CAS操作来加锁和解锁，只需简单检查一下Mark Word里是否存储着自己的线程ID。

2.  **轻量级锁**：
    - **场景**：当有**轻微竞争**，另一个线程来尝试获取锁。
    - **做法**：JVM会在当前线程的栈帧中创建一个名为**锁记录**的空间，然后将对象头的Mark Word复制过去。然后，线程尝试用**CAS操作**将对象头的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁；如果失败，表示有其他线程竞争，则**膨胀为重量级锁**。

3.  **重量级锁**：
    - **场景**：**竞争激烈**，轻量级锁自旋一定次数后依然无法获取锁。
    - **做法**：向操作系统申请**互斥量**。此时，未获取到锁的线程会被**挂起**，进入阻塞状态，等待操作系统调度唤醒。这个过程的成本最高，涉及到用户态到内核态的切换。

### 总结与对比

| 锁类型 | 优点 | 缺点 | 适用场景 |
| :--- | :--- | :--- | :--- |
| **偏向锁** | 加锁解锁无需额外消耗 | 如果存在锁竞争，会带来额外的撤销消耗 | 只有一个线程访问同步块 |
| **轻量级锁** | 竞争的线程不会阻塞，响应快 | 始终得不到锁的线程，会自旋消耗CPU | 追求响应时间，同步块执行非常快 |
| **重量级锁** | 竞争激烈时，自旋的CPU消耗少 | 线程阻塞，响应时间缓慢 | 追求吞吐量，同步块执行时间较长 |

#### 面试回答模板
> 关于synchronized的原理，我从三个层面理解：
> 1. 字节码层面：依赖于monitorenter和monitorexit指令。
> 2. JVM层面：锁的具体信息存储在对象头的Mark Word中。
> 3. 锁优化层面：为了平衡性能，JVM设计了偏向锁、轻量级锁、重量级锁的升级过程，根据竞争激烈程度动态切换。”
> 
> “它的保证的可见性和有序性，是通过在解锁时必须将工作内存的变量刷回主内存，以及‘一个变量在同一时刻只允许一条线程对其进行lock操作’这条规则来实现的。”