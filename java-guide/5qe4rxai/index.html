<!doctype html><html lang="zh-CN"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width,initial-scale=1" /><meta name="generator" content="VuePress 2.0.0-rc.24" /><meta name="theme" content="VuePress Theme Plume 1.0.0-rc.161" /><script id="check-mac-os">document.documentElement.classList.toggle('mac', /Mac|iPhone|iPod|iPad/i.test(navigator.platform))</script><script id="check-dark-mode">;(function () {const um= localStorage.getItem('vuepress-theme-appearance') || 'auto';const sm = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;const isDark = um === 'dark' || (um !== 'light' && sm);document.documentElement.dataset.theme = isDark ? 'dark' : 'light';})();</script><link rel="icon" type="image/png" href="https://theme-plume.vuejs.press/favicon-32x32.png"><title>Java 并发编程 | 浮梦札记</title><meta name="description" content=""><link rel="preload" href="/assets/style-DrEZvK8Z.css" as="style"><link rel="stylesheet" href="/assets/style-DrEZvK8Z.css"><link rel="modulepreload" href="/assets/app-DqL0oT9G.js"><link rel="modulepreload" href="/assets/index.html-B8t-yzQR.js"></head><body><div id="app"><!--[--><!--[--><div class="theme-plume vp-layout" vp-container data-v-e1dbaae2><!--[--><!--[--><!--]--><!--[--><span tabindex="-1" data-v-889cca3e></span><a href="#VPContent" class="vp-skip-link visually-hidden" data-v-889cca3e> Skip to content </a><!--]--><!----><header class="vp-nav" data-v-e1dbaae2 data-v-98c50ae5><div class="vp-navbar" vp-navbar data-v-98c50ae5 data-v-1eff3e5c><div class="wrapper" data-v-1eff3e5c><div class="container" data-v-1eff3e5c><div class="title" data-v-1eff3e5c><div class="vp-navbar-title has-sidebar" data-v-1eff3e5c data-v-a8561eab><a class="vp-link link no-icon title" href="/" data-v-a8561eab><!--[--><!--[--><!--]--><!--[--><!--[--><!--[--><img class="vp-image dark logo" style="" src="https://theme-plume.vuejs.press/plume.png" alt data-v-77c293cb><!--]--><!--[--><img class="vp-image light logo" style="" src="https://theme-plume.vuejs.press/plume.png" alt data-v-77c293cb><!--]--><!--]--><!--]--><span data-v-a8561eab>浮梦札记</span><!--[--><!--]--><!--]--><!----></a></div></div><div class="content" data-v-1eff3e5c><div class="content-body" data-v-1eff3e5c><!--[--><!--]--><div class="vp-navbar-search search" data-v-1eff3e5c><div class="search-wrapper" data-v-3c688d23><!----><div id="local-search" data-v-3c688d23><button type="button" class="mini-search mini-search-button" aria-label="搜索文档" data-v-3c688d23><span class="mini-search-button-container"><span class="mini-search-search-icon vpi-mini-search" aria-label="search icon"></span><span class="mini-search-button-placeholder">搜索文档</span></span><span class="mini-search-button-keys"><kbd class="mini-search-button-key"></kbd><kbd class="mini-search-button-key">K</kbd></span></button></div></div></div><!--[--><!--]--><nav aria-labelledby="main-nav-aria-label" class="vp-navbar-menu menu" data-v-1eff3e5c data-v-0840a817><span id="main-nav-aria-label" class="visually-hidden" data-v-0840a817>Main Navigation</span><!--[--><!--[--><a class="vp-link link navbar-menu-link" href="/" tabindex="0" data-v-0840a817 data-v-950c9576><!--[--><!----><span data-v-950c9576>首页</span><!----><!--]--><!----></a><!--]--><!--[--><a class="vp-link link navbar-menu-link" href="/java-guide/" tabindex="0" data-v-0840a817 data-v-950c9576><!--[--><!----><span data-v-950c9576>面试指北</span><!----><!--]--><!----></a><!--]--><!--[--><a class="vp-link link navbar-menu-link" href="/notes/" tabindex="0" data-v-0840a817 data-v-950c9576><!--[--><!----><span data-v-950c9576>笔记</span><!----><!--]--><!----></a><!--]--><!--[--><a class="vp-link link navbar-menu-link" href="/ai/" tabindex="0" data-v-0840a817 data-v-950c9576><!--[--><!----><span data-v-950c9576>AI</span><!----><!--]--><!----></a><!--]--><!--]--></nav><!--[--><!--]--><!----><div class="vp-navbar-appearance appearance" data-v-1eff3e5c data-v-d98d8427><button class="vp-switch vp-switch-appearance" type="button" role="switch" title aria-checked="false" data-v-d98d8427 data-v-4421fe29 data-v-05519a3d><span class="check" data-v-05519a3d><span class="icon" data-v-05519a3d><!--[--><span class="vpi-sun sun" data-v-4421fe29></span><span class="vpi-moon moon" data-v-4421fe29></span><!--]--></span></span></button></div><div class="vp-social-links vp-navbar-social-links social-links" data-v-1eff3e5c data-v-ede9f760 data-v-2c613800><!--[--><a class="vp-social-link no-icon" href="/" aria-label="github" target="_blank" rel="noopener" data-v-2c613800 data-v-dbe9afc8><span class="vpi-social-github" /></a><!--]--></div><div class="vp-flyout vp-navbar-extra extra" data-v-1eff3e5c data-v-2ef44bf2 data-v-fd7634eb><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-fd7634eb><span class="vpi-more-horizontal icon" data-v-fd7634eb></span></button><div class="menu" data-v-fd7634eb><div class="vp-menu" data-v-fd7634eb data-v-f00c3ea6><!----><!--[--><!--[--><!----><div class="group" data-v-2ef44bf2><div class="item appearance" data-v-2ef44bf2><p class="label" data-v-2ef44bf2>外观</p><div class="appearance-action" data-v-2ef44bf2><button class="vp-switch vp-switch-appearance" type="button" role="switch" title aria-checked="false" data-v-2ef44bf2 data-v-4421fe29 data-v-05519a3d><span class="check" data-v-05519a3d><span class="icon" data-v-05519a3d><!--[--><span class="vpi-sun sun" data-v-4421fe29></span><span class="vpi-moon moon" data-v-4421fe29></span><!--]--></span></span></button></div></div></div><div class="group" data-v-2ef44bf2><div class="item social-links" data-v-2ef44bf2><div class="vp-social-links social-links-list" data-v-2ef44bf2 data-v-2c613800><!--[--><a class="vp-social-link no-icon" href="/" aria-label="github" target="_blank" rel="noopener" data-v-2c613800 data-v-dbe9afc8><span class="vpi-social-github" /></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="vp-navbar-hamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="nav-screen" data-v-1eff3e5c data-v-54c2ef6c><span class="container" data-v-54c2ef6c><span class="top" data-v-54c2ef6c></span><span class="middle" data-v-54c2ef6c></span><span class="bottom" data-v-54c2ef6c></span></span></button></div></div></div></div><div class="divider" data-v-1eff3e5c><div class="divider-line" data-v-1eff3e5c></div></div></div><!----></header><div class="vp-local-nav reached-top" data-v-e1dbaae2 data-v-734ba265><button class="menu" aria-expanded="false" aria-controls="SidebarNav" data-v-734ba265><span class="vpi-align-left menu-icon" data-v-734ba265></span><span class="menu-text" data-v-734ba265>Menu</span></button><div class="vp-local-nav-outline-dropdown" style="--vp-vh:0px;" data-v-734ba265 data-v-1e80eb91><button data-v-1e80eb91>返回顶部</button><!----></div></div><aside class="vp-sidebar" vp-sidebar data-v-e1dbaae2 data-v-aa9e4082><div class="curtain" data-v-aa9e4082></div><nav id="SidebarNav" class="nav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-aa9e4082><span id="sidebar-aria-label" class="visually-hidden" data-v-aa9e4082> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-5ddb9693><section class="vp-sidebar-item sidebar-item level-0 collapsible has-active" data-v-5ddb9693 data-v-01c8a1fd><div class="item" role="button" tabindex="0" data-v-01c8a1fd><div class="indicator" data-v-01c8a1fd></div><!----><h2 class="text" data-v-01c8a1fd><span data-v-01c8a1fd>Java</span><!----></h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-01c8a1fd><span class="vpi-chevron-right caret-icon" data-v-01c8a1fd></span></div></div><div data-v-01c8a1fd data-v-01c8a1fd><div class="items" data-v-01c8a1fd><!--[--><div class="vp-sidebar-item sidebar-item level-1 is-link" data-v-01c8a1fd data-v-01c8a1fd><div class="item" data-v-01c8a1fd><div class="indicator" data-v-01c8a1fd></div><!----><a class="vp-link link link" href="/java-guide/hg5e8awy/" data-v-01c8a1fd><!--[--><p class="text" data-v-01c8a1fd><span data-v-01c8a1fd>Java 基础</span><!----></p><!--]--><!----></a><!----></div><!----></div><div class="vp-sidebar-item sidebar-item level-1 is-link" data-v-01c8a1fd data-v-01c8a1fd><div class="item" data-v-01c8a1fd><div class="indicator" data-v-01c8a1fd></div><!----><a class="vp-link link link" href="/java-guide/h9mgtev9/" data-v-01c8a1fd><!--[--><p class="text" data-v-01c8a1fd><span data-v-01c8a1fd>Java 集合</span><!----></p><!--]--><!----></a><!----></div><!----></div><div class="vp-sidebar-item sidebar-item level-1 is-link" data-v-01c8a1fd data-v-01c8a1fd><div class="item" data-v-01c8a1fd><div class="indicator" data-v-01c8a1fd></div><!----><a class="vp-link link link" href="/java-guide/5qe4rxai/" data-v-01c8a1fd><!--[--><p class="text" data-v-01c8a1fd><span data-v-01c8a1fd>Java 并发编程</span><!----></p><!--]--><!----></a><!----></div><!----></div><div class="vp-sidebar-item sidebar-item level-1 is-link" data-v-01c8a1fd data-v-01c8a1fd><div class="item" data-v-01c8a1fd><div class="indicator" data-v-01c8a1fd></div><!----><a class="vp-link link link" href="/java-guide/ypjcijom/" data-v-01c8a1fd><!--[--><p class="text" data-v-01c8a1fd><span data-v-01c8a1fd>Java 虚拟机</span><!----></p><!--]--><!----></a><!----></div><!----></div><!--]--></div></div></section></div><div class="no-transition group" data-v-5ddb9693><section class="vp-sidebar-item sidebar-item level-0 collapsible" data-v-5ddb9693 data-v-01c8a1fd><div class="item" role="button" tabindex="0" data-v-01c8a1fd><div class="indicator" data-v-01c8a1fd></div><!----><h2 class="text" data-v-01c8a1fd><span data-v-01c8a1fd>数据库</span><!----></h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-01c8a1fd><span class="vpi-chevron-right caret-icon" data-v-01c8a1fd></span></div></div><div data-v-01c8a1fd data-v-01c8a1fd><div class="items" data-v-01c8a1fd><!--[--><div class="vp-sidebar-item sidebar-item level-1 is-link" data-v-01c8a1fd data-v-01c8a1fd><div class="item" data-v-01c8a1fd><div class="indicator" data-v-01c8a1fd></div><!----><a class="vp-link link link" href="/java-guide/396o7sc3/" data-v-01c8a1fd><!--[--><p class="text" data-v-01c8a1fd><span data-v-01c8a1fd>MySQL</span><!----></p><!--]--><!----></a><!----></div><!----></div><!--]--></div></div></section></div><div class="no-transition group" data-v-5ddb9693><section class="vp-sidebar-item sidebar-item level-0 collapsible" data-v-5ddb9693 data-v-01c8a1fd><div class="item" role="button" tabindex="0" data-v-01c8a1fd><div class="indicator" data-v-01c8a1fd></div><!----><h2 class="text" data-v-01c8a1fd><span data-v-01c8a1fd>Spring</span><!----></h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-01c8a1fd><span class="vpi-chevron-right caret-icon" data-v-01c8a1fd></span></div></div><div data-v-01c8a1fd data-v-01c8a1fd><div class="items" data-v-01c8a1fd><!--[--><div class="vp-sidebar-item sidebar-item level-1 is-link" data-v-01c8a1fd data-v-01c8a1fd><div class="item" data-v-01c8a1fd><div class="indicator" data-v-01c8a1fd></div><!----><a class="vp-link link link" href="/java-guide/ysb3pgbj/" data-v-01c8a1fd><!--[--><p class="text" data-v-01c8a1fd><span data-v-01c8a1fd>Spring</span><!----></p><!--]--><!----></a><!----></div><!----></div><!--]--></div></div></section></div><div class="no-transition group" data-v-5ddb9693><section class="vp-sidebar-item sidebar-item level-0 collapsible" data-v-5ddb9693 data-v-01c8a1fd><div class="item" role="button" tabindex="0" data-v-01c8a1fd><div class="indicator" data-v-01c8a1fd></div><!----><h2 class="text" data-v-01c8a1fd><span data-v-01c8a1fd>其他</span><!----></h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-01c8a1fd><span class="vpi-chevron-right caret-icon" data-v-01c8a1fd></span></div></div><div data-v-01c8a1fd data-v-01c8a1fd><div class="items" data-v-01c8a1fd><!--[--><div class="vp-sidebar-item sidebar-item level-1 is-link" data-v-01c8a1fd data-v-01c8a1fd><div class="item" data-v-01c8a1fd><div class="indicator" data-v-01c8a1fd></div><!----><a class="vp-link link link" href="/java-guide/nkmdr64r/" data-v-01c8a1fd><!--[--><p class="text" data-v-01c8a1fd><span data-v-01c8a1fd>软技能</span><!----></p><!--]--><!----></a><!----></div><!----></div><!--]--></div></div></section></div><!--]--><!--[--><!--]--></nav></aside><!--[--><div id="VPContent" vp-content class="vp-content has-sidebar" data-v-e1dbaae2 data-v-4f97ed91><div class="vp-doc-container has-sidebar has-aside" data-v-4f97ed91 data-v-79596a8a><!--[--><!--]--><div class="container" data-v-79596a8a><div class="aside" vp-outline data-v-79596a8a><div class="aside-curtain" data-v-79596a8a></div><div class="aside-container" data-v-79596a8a><div class="aside-content" data-v-79596a8a><div class="vp-doc-aside" data-v-79596a8a data-v-95f703c6><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="vp-doc-aside-outline" role="navigation" data-v-95f703c6 data-v-937f11d8><div class="content" data-v-937f11d8><div class="outline-marker" data-v-937f11d8></div><div id="doc-outline-aria-label" aria-level="2" class="outline-title" role="heading" data-v-937f11d8><span data-v-937f11d8>此页内容</span><span class="vpi-print icon" data-v-937f11d8></span></div><ul class="root" data-v-937f11d8 data-v-8fe7a250><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-95f703c6></div><!--[--><!--]--></div></div></div></div><div class="content" data-v-79596a8a><div class="content-container" data-v-79596a8a><!--[--><!--]--><main class="main" data-v-79596a8a><nav class="vp-breadcrumb" data-v-79596a8a data-v-06b62c47><ol vocab="https://schema.org/" typeof="BreadcrumbList" data-v-06b62c47><!--[--><li property="itemListElement" typeof="ListItem" data-v-06b62c47><a class="vp-link link breadcrumb" href="/" property="item" typeof="WebPage" data-v-06b62c47><!--[-->首页<!--]--><!----></a><span class="vpi-chevron-right" data-v-06b62c47></span><meta property="name" content="首页" data-v-06b62c47><meta property="position" content="1" data-v-06b62c47></li><li property="itemListElement" typeof="ListItem" data-v-06b62c47><span class="vp-link breadcrumb" property="item" typeof="WebPage" data-v-06b62c47><!--[-->Java<!--]--><!----></span><span class="vpi-chevron-right" data-v-06b62c47></span><meta property="name" content="Java" data-v-06b62c47><meta property="position" content="2" data-v-06b62c47></li><li property="itemListElement" typeof="ListItem" data-v-06b62c47><a class="vp-link link breadcrumb current" href="/java-guide/5qe4rxai/" property="item" typeof="WebPage" data-v-06b62c47><!--[-->Java 并发编程<!--]--><!----></a><!----><meta property="name" content="Java 并发编程" data-v-06b62c47><meta property="position" content="3" data-v-06b62c47></li><!--]--></ol></nav><!--[--><!--]--><!--[--><h1 class="vp-doc-title page-title" data-v-09347631><!----> Java 并发编程 <!----></h1><div class="vp-doc-meta" data-v-09347631><!--[--><!--]--><p class="reading-time" data-v-09347631><span class="vpi-books icon" data-v-09347631></span><span data-v-09347631>约 6026 字</span><span data-v-09347631>大约 20 分钟</span></p><!----><!--[--><!--]--><p class="create-time" data-v-09347631><span class="vpi-clock icon" data-v-09347631></span><span data-v-09347631>2025-09-03</span></p></div><!--]--><!--[--><!--]--><div class="_java-guide_5qe4rxai_ external-link-icon-enabled vp-doc plume-content" vp-content data-v-79596a8a><!--[--><!--]--><div data-v-79596a8a><h2 id="synchronized的实现原理" tabindex="-1"><a class="header-anchor" href="#synchronized的实现原理"><span>Synchronized的实现原理</span></a></h2><blockquote><p>“大家都知道 <code>synchronized</code> 是Java里的‘同步锁’，用它包裹的代码能保证线程安全。但你有没有想过，这个‘锁’到底长什么样？它被存在了哪里？为什么有的锁效率高，有的锁效率低？</p></blockquote><h3 id="🌰-synchronized的三种用法" tabindex="-1"><a class="header-anchor" href="#🌰-synchronized的三种用法"><span>🌰 Synchronized的三种用法</span></a></h3><p>首先，我们要明确<code>synchronized</code>可以锁在哪里，这是理解其原理的基础。</p><table><thead><tr><th style="text-align:left;">用法</th><th style="text-align:left;">示例</th><th style="text-align:left;">锁的对象</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>实例方法</strong></td><td style="text-align:left;"><code>public synchronized void method()</code></td><td style="text-align:left;"><strong>当前实例对象</strong> (<code>this</code>)</td></tr><tr><td style="text-align:left;"><strong>静态方法</strong></td><td style="text-align:left;"><code>public static synchronized void method()</code></td><td style="text-align:left;"><strong>当前类的Class对象</strong> (如 <code>MyClass.class</code>)</td></tr><tr><td style="text-align:left;"><strong>代码块</strong></td><td style="text-align:left;"><code>synchronized(obj) { ... }</code></td><td style="text-align:left;"><strong>括号里配置的对象</strong> (<code>obj</code>)</td></tr></tbody></table><p><strong>核心概念：</strong> 无论哪种用法，synchronized锁住的都是一个<strong>Java对象</strong>。</p><h3 id="🔍-jvm中的实现原理" tabindex="-1"><a class="header-anchor" href="#🔍-jvm中的实现原理"><span>🔍 JVM中的实现原理</span></a></h3><p>这是内容的精髓，我们必须分层解析。</p><h4 id="层面一-字节码层面-——-monitorenter-与-monitorexit" tabindex="-1"><a class="header-anchor" href="#层面一-字节码层面-——-monitorenter-与-monitorexit"><span>层面一：字节码层面 —— <code>monitorenter</code> 与 <code>monitorexit</code></span></a></h4><p>我们可以通过一个清晰的流程图，来看当线程进入和退出同步块时，在字节码层面和JVM层面发生了什么： <img src="/images/synchronized_flow1.png" alt=""></p><p>当我们编译一个<code>synchronized</code>代码块时，编译器会在同步代码块的前后分别生成 <code>monitorenter</code> 和 <code>monitorexit</code> 指令。</p><ul><li><code>monitorenter</code>：尝试<strong>进入</strong>并持有该对象的监视器。</li><li><code>monitorexit</code>：<strong>释放</strong>该对象的监视器。</li></ul><p><strong>这两条指令的背后，是JVM与操作系统协同工作的结果。</strong></p><h4 id="层面二-对象头与mark-word-锁的物理载体" tabindex="-1"><a class="header-anchor" href="#层面二-对象头与mark-word-锁的物理载体"><span>层面二：对象头与Mark Word (锁的物理载体)</span></a></h4><p><strong>锁实际上是存在每个Java对象的对象头里的。</strong> 对象头主要包括两部分：</p><ol><li><strong>Mark Word</strong>：存储对象自身的运行时数据，如<strong>哈希码、GC分代年龄、锁状态标志</strong>等。这是实现锁的关键！</li><li><strong>Klass Pointer</strong>：对象指向它的类型元数据的指针。</li></ol><p>为了更直观地理解Mark Word如何作为锁信息的载体，下图展示了32位JVM下Mark Word在不同锁状态下的内存布局：</p><table><thead><tr><th style="text-align:left;">锁状态</th><th style="text-align:left;">25 bits</th><th style="text-align:left;">4 bits</th><th style="text-align:left;">1 bit</th><th style="text-align:left;">2 bits</th><th style="text-align:left;"><strong>对应“形态”说明</strong></th></tr></thead><tbody><tr><td style="text-align:left;"><strong>无锁 (可偏向)</strong></td><td style="text-align:left;"><strong><code>identity_hashcode</code></strong></td><td style="text-align:left;"><strong><code>age</code></strong></td><td style="text-align:left;"><strong><code>biased_lock=0</code></strong></td><td style="text-align:left;"><strong><code>lock=01</code></strong></td><td style="text-align:left;">这是你给出的结构。此时对象未被锁定，但<strong>允许偏向</strong>。如果计算过hashCode，则25位用于存储。</td></tr><tr><td style="text-align:left;"><strong>偏向锁</strong></td><td style="text-align:left;"><strong><code>thread:23</code> + <code>epoch:2</code></strong></td><td style="text-align:left;"><strong><code>age</code></strong></td><td style="text-align:left;"><strong><code>biased_lock=1</code></strong></td><td style="text-align:left;"><strong><code>lock=01</code></strong></td><td style="text-align:left;"><strong>形态改变！</strong> 当有线程偏向时，23位存储线程ID，2位存储epoch，<strong>原有的hashCode存储被覆盖</strong>。</td></tr><tr><td style="text-align:left;"><strong>轻量级锁</strong></td><td style="text-align:left;"><strong><code>pointer_to_lock_record:30</code></strong></td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"><strong><code>lock=00</code></strong></td><td style="text-align:left;"><strong>形态彻底改变！</strong> 30位指向线程栈帧中的锁记录指针。</td></tr><tr><td style="text-align:left;"><strong>重量级锁</strong></td><td style="text-align:left;"><strong><code>pointer_to_monitor:30</code></strong></td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"><strong><code>lock=10</code></strong></td><td style="text-align:left;"><strong>形态彻底改变！</strong> 30位指向互斥量（monitor）的指针。</td></tr><tr><td style="text-align:left;"><strong>GC标记</strong></td><td style="text-align:left;">(已忽略)</td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"><strong><code>lock=11</code></strong></td><td style="text-align:left;">被垃圾回收器标记时使用。</td></tr></tbody></table><h4 id="层面三-锁的升级与优化" tabindex="-1"><a class="header-anchor" href="#层面三-锁的升级与优化"><span>层面三：锁的升级与优化</span></a></h4><p>为了提高性能，JVM中的锁会从低开销到高开销进行升级。这个过程是不可逆的，目的就是为了减少直接使用重量级锁带来的性能损耗。</p><ol><li><p><strong>偏向锁</strong>：</p><ul><li><strong>目标</strong>：解决在<strong>没有竞争</strong>情况下，同一个线程重复获取锁的性能开销。</li><li><strong>做法</strong>：当第一个线程访问同步块时，会在Mark Word里记录自己的线程ID。以后该线程再进入和退出同步块时，不需要进行CAS操作来加锁和解锁，只需简单检查一下Mark Word里是否存储着自己的线程ID。</li></ul></li><li><p><strong>轻量级锁</strong>：</p><ul><li><strong>场景</strong>：当有<strong>轻微竞争</strong>，另一个线程来尝试获取锁。</li><li><strong>做法</strong>：JVM会在当前线程的栈帧中创建一个名为<strong>锁记录</strong>的空间，然后将对象头的Mark Word复制过去。然后，线程尝试用<strong>CAS操作</strong>将对象头的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁；如果失败，表示有其他线程竞争，则<strong>膨胀为重量级锁</strong>。</li></ul></li><li><p><strong>重量级锁</strong>：</p><ul><li><strong>场景</strong>：<strong>竞争激烈</strong>，轻量级锁自旋一定次数后依然无法获取锁。</li><li><strong>做法</strong>：向操作系统申请<strong>互斥量</strong>。此时，未获取到锁的线程会被<strong>挂起</strong>，进入阻塞状态，等待操作系统调度唤醒。这个过程的成本最高，涉及到用户态到内核态的切换。</li></ul></li></ol><h3 id="🆚-锁对比" tabindex="-1"><a class="header-anchor" href="#🆚-锁对比"><span>🆚 锁对比</span></a></h3><table><thead><tr><th style="text-align:left;">锁类型</th><th style="text-align:left;">优点</th><th style="text-align:left;">缺点</th><th style="text-align:left;">适用场景</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>偏向锁</strong></td><td style="text-align:left;">加锁解锁无需额外消耗</td><td style="text-align:left;">如果存在锁竞争，会带来额外的撤销消耗</td><td style="text-align:left;">只有一个线程访问同步块</td></tr><tr><td style="text-align:left;"><strong>轻量级锁</strong></td><td style="text-align:left;">竞争的线程不会阻塞，响应快</td><td style="text-align:left;">始终得不到锁的线程，会自旋消耗CPU</td><td style="text-align:left;">追求响应时间，同步块执行非常快</td></tr><tr><td style="text-align:left;"><strong>重量级锁</strong></td><td style="text-align:left;">竞争激烈时，自旋的CPU消耗少</td><td style="text-align:left;">线程阻塞，响应时间缓慢</td><td style="text-align:left;">追求吞吐量，同步块执行时间较长</td></tr></tbody></table><h3 id="📌-总结" tabindex="-1"><a class="header-anchor" href="#📌-总结"><span>📌 总结</span></a></h3><blockquote><p>关于synchronized的原理，从三个层面理解：</p><ol><li>字节码层面：依赖于monitorenter和monitorexit指令。</li><li>JVM层面：锁的具体信息存储在对象头的Mark Word中。</li><li>锁优化层面：为了平衡性能，JVM设计了偏向锁、轻量级锁、重量级锁的升级过程，根据竞争激烈程度动态切换。”</li></ol><p>“它的保证的可见性和有序性，是通过在解锁时必须将工作内存的变量刷回主内存，以及‘一个变量在同一时刻只允许一条线程对其进行lock操作’这条规则来实现的。”</p></blockquote><h2 id="synchronized-vs-reentrantlock-如何抉择" tabindex="-1"><a class="header-anchor" href="#synchronized-vs-reentrantlock-如何抉择"><span>synchronized VS ReentrantLock 如何抉择</span></a></h2><blockquote><p>“在JDK1.6之前，ReentrantLock在性能上对synchronized是碾压性的优势。但1.6之后，synchronized被重写了底层，加入了偏向锁、轻量级锁等优化，<strong>两者在性能上已相差无几</strong>。所以现在的抉择就不再是‘谁更快’，而是 <strong>‘谁更能解决我的实际问题’</strong> 。</p></blockquote><h3 id="🆚-核心差异对比" tabindex="-1"><a class="header-anchor" href="#🆚-核心差异对比"><span>🆚 核心差异对比</span></a></h3><table><thead><tr><th style="text-align:left;">特性维度</th><th style="text-align:left;">🗝️ synchronized (JVM内置锁)</th><th style="text-align:left;">🔌 ReentrantLock (API层面的锁)</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>获取与释放</strong></td><td style="text-align:left;"><strong>自动管理</strong>。JVM负责在代码块入口和出口加锁、释放锁，不会遗忘。</td><td style="text-align:left;"><strong>手动管理</strong>。必须显式调用 <code>lock()</code> 和 <code>unlock()</code>，易遗忘，需在 <code>finally</code> 中释放。</td></tr><tr><td style="text-align:left;"><strong>可中断性</strong></td><td style="text-align:left;"><strong>不可中断</strong>。线程若争抢不到锁，会一直阻塞，无法响应中断。</td><td style="text-align:left;"><strong>可中断</strong>。提供了 <code>lockInterruptibly()</code> 方法，在等待锁时可以响应线程中断。</td></tr><tr><td style="text-align:left;"><strong>公平性</strong></td><td style="text-align:left;"><strong>仅支持非公平锁</strong>。</td><td style="text-align:left;"><strong>支持两者</strong>。构造函数可传入 <code>true</code> 来创建公平锁，防止线程饥饿。</td></tr><tr><td style="text-align:left;"><strong>超时机制</strong></td><td style="text-align:left;"><strong>不支持</strong>。</td><td style="text-align:left;"><strong>支持</strong>。<code>tryLock(long timeout, TimeUnit unit)</code> 可尝试获取锁，超时则放弃。</td></tr><tr><td style="text-align:left;"><strong>绑定条件</strong></td><td style="text-align:left;"><strong>单一等待队列</strong>。<code>wait()</code>/<code>notify()</code>/<code>notifyAll()</code> 随机唤醒。</td><td style="text-align:left;"><strong>多个Condition</strong>。一个锁可以绑定多个条件队列，实现精确唤醒。</td></tr><tr><td style="text-align:left;"><strong>锁粒度</strong></td><td style="text-align:left;">方法或代码块。</td><td style="text-align:left;">更灵活，锁的获取和释放可以跨越方法。</td></tr><tr><td style="text-align:left;"><strong>性能趋势</strong></td><td style="text-align:left;">JDK1.6后优化很好，在<strong>低至中度竞争</strong>下性能极佳。</td><td style="text-align:left;">在高竞争环境下，仍能保持稳定，提供了更丰富的<strong>避免竞争</strong>的手段。</td></tr></tbody></table><h3 id="🔍-核心优势场景深度解析" tabindex="-1"><a class="header-anchor" href="#🔍-核心优势场景深度解析"><span>🔍 核心优势场景深度解析</span></a></h3><h4 id="_1-何时优先选择synchronized" tabindex="-1"><a class="header-anchor" href="#_1-何时优先选择synchronized"><span>1. 何时优先选择synchronized？</span></a></h4><ul><li><p><strong>场景一：追求开发效率与可靠性</strong></p><ul><li><strong>理由</strong>：语法简洁，自动释放，无需担心因异常导致锁无法释放的问题。这是它<strong>最核心的优势</strong>。</li><li><strong>代码对比</strong>：<div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// synchronized: 简洁，可靠</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> synchronized</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> add</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // ... 业务逻辑</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// ReentrantLock: 繁琐，需手动处理</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">private</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ReentrantLock</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> lock</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> ReentrantLock</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> add</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">    lock</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">lock</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 如果这里发生异常，锁还沒获取到</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    try</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">        // ... 业务逻辑</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> finally</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">        lock</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">unlock</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 必须放在finally块，确保锁释放</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p><strong>场景二：绝大多数并发场景</strong></p><ul><li><strong>理由</strong>：在大部分业务系统中，锁的竞争并不激烈。synchronized经过优化后，在这种情况下性能非常好，且JVM会自动进行锁升级/降级，无需开发者关心。</li></ul></li></ul><h4 id="_2-何时应考虑-reentrantlock" tabindex="-1"><a class="header-anchor" href="#_2-何时应考虑-reentrantlock"><span>2. 何时应考虑 ReentrantLock？</span></a></h4><ul><li><p><strong>场景一：需要应对“死等”风险 —— 可中断与超时</strong></p><ul><li><strong>案例</strong>：一个转账服务，需要同时获取A锁和B锁。如果线程T1持有A等B，T2持有B等A，形成死锁。</li><li><strong>synchronized方案</strong>：无解，只能重启。</li><li><strong>ReentrantLock方案</strong>：使用 <code>tryLock</code> 进行尝试。<div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">lockA</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">tryLock</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> TimeUnit</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">SECONDS</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">))</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 尝试获取锁A，等1秒</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    try</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">        if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">lockB</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">tryLock</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> TimeUnit</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">SECONDS</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">))</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 尝试获取锁B，等1秒</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">            try</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">                // ... 执行转账业务</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">            }</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> finally</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">                lockB</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">unlock</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">            }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> finally</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">        lockA</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">unlock</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> else</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 记录日志，执行补偿逻辑，不会死锁</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p><strong>场景二：实现“先来后到” —— 公平锁</strong></p><ul><li><strong>案例</strong>：一个票务系统，希望先请求的用户先买到票，避免某些用户一直抢不到（线程饥饿）。</li><li><strong>解决方案</strong>：使用 <code>new ReentrantLock(true)</code>。</li></ul></li><li><p><strong>场景三：实现“分组唤醒” —— 条件变量 (Condition)</strong></p><ul><li><strong>经典案例：生产者-消费者模型</strong>。我们希望生产者只唤醒消费者，消费者只唤醒生产者，而不是把所有等待线程都唤醒。</li><li><strong>synchronized方案</strong>：使用 <code>Object.wait()</code> 和 <code>Object.notifyAll()</code>，但 <code>notifyAll()</code> 会唤醒所有等待的生产者和消费者，效率低。</li><li><strong>ReentrantLock方案</strong>：使用两个Condition。<div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">private</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ReentrantLock</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> lock</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> ReentrantLock</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">private</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> Condition</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> notFull</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> lock</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">newCondition</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 队列未满条件</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">private</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> Condition</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> notEmpty</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> lock</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">newCondition</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 队列非空条件</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 生产者</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> put</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Object item</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> throws InterruptedException </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">    lock</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">lock</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    try</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">        while</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">queue</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">isFull</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">())</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">            notFull</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">await</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 在“未满”条件上等待</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        }</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">        // ... 生产数据</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">        notEmpty</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">signal</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 精准唤醒一个在“非空”条件上等待的消费者</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> finally</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">        lock</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">unlock</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 消费者同理，使用notEmpty.await()和notFull.signal()</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><h3 id="📌-总结-1" tabindex="-1"><a class="header-anchor" href="#📌-总结-1"><span>📌 总结</span></a></h3><blockquote><p>“<strong>优先使用synchronized</strong>。因为在JDK1.6优化后，它的性能已经不差，而且语法简单、由JVM自动管理，能有效减少编码错误。只有在需要synchronized无法提供的<strong>高级功能</strong>时，我才会考虑使用ReentrantLock，比如：</p><ol><li><strong>需要尝试获取锁</strong>，用于解决死锁或苛刻的超时控制。</li><li><strong>需要公平锁</strong>，来处理线程饥饿问题。</li><li><strong>需要可中断的锁</strong>，让线程在等待时能响应外部中断。</li><li><strong>需要绑定多个条件变量</strong>，来实现线程间的精确通知，比如经典的生产者-消费者模型。”</li></ol></blockquote><h2 id="volatile是线程安全的吗" tabindex="-1"><a class="header-anchor" href="#volatile是线程安全的吗"><span>volatile是线程安全的吗</span></a></h2><blockquote><p>“很多同学一看到 <code>volatile</code> 和‘线程’、‘变量’联系在一起，就下意识地认为它是线程安全的。<strong>这是一个危险的误解！</strong> 今天，我们就一起来彻底拆解 <code>volatile</code>：它能做什么，不能做什么，以及它的底层实现原理。”</p></blockquote><p>先说结论：<strong>volatile不是线程安全的</strong></p><p>首先，我们必须明确一个核心结论：<strong><code>volatile</code> 解决的是变量在多个线程间的‘可见性’问题，但它不保证复合操作的‘原子性’。</strong></p><p>为了更直观地理解它在并发安全中的独特定位，可以参考下面的“并发安全三要素”剖析图： <img src="/images/juc_safe_3.png" alt=""></p><p>从上图可以清晰地看到，<code>volatile</code> 只解决了三要素中的“可见性”和部分“有序性”，但最关键的“原子性”它无法保证。因此，它本身<strong>不是线程安全</strong>的。</p><h3 id="🔍-原理探秘-jmm与内存屏障" tabindex="-1"><a class="header-anchor" href="#🔍-原理探秘-jmm与内存屏障"><span>🔍 原理探秘：JMM与内存屏障</span></a></h3><p><code>volatile</code> 的实现原理，深植于 <strong>Java内存模型</strong> 之中。</p><h4 id="_1-可见性原理-绕过工作内存" tabindex="-1"><a class="header-anchor" href="#_1-可见性原理-绕过工作内存"><span>1. 可见性原理：绕过工作内存</span></a></h4><ul><li><strong>普通变量</strong>：线程A从主内存读取变量到自己的工作内存，修改后，不一定立即写回主内存。线程B此时读取的可能是主内存中的旧值。</li><li><strong>volatile变量</strong>： <ul><li><strong>写操作</strong>：当写一个 <code>volatile</code> 变量时，JMM会<strong>立即</strong>将该线程对应的工作内存中的新值<strong>强制刷新到主内存</strong>中。</li><li><strong>读操作</strong>：当读一个 <code>volatile</code> 变量时，JMM会使该线程的工作内存中的缓存失效，从而<strong>必须从主内存中重新读取</strong>最新值。</li></ul></li></ul><h4 id="_2-有序性原理-内存屏障" tabindex="-1"><a class="header-anchor" href="#_2-有序性原理-内存屏障"><span>2. 有序性原理：内存屏障</span></a></h4><p>为了实现可见性和禁止指令重排序，JVM在编译器和CPU级别使用了 <strong>“内存屏障”</strong>。你可以把内存屏障理解为一堵墙，告诉编译器和CPU：“屏障前的指令和屏障后的指令，不能乱序执行”。</p><p>对于 <code>volatile</code> 变量，JVM会在其读写操作前后插入特定的内存屏障：</p><table><thead><tr><th style="text-align:left;">场景</th><th style="text-align:left;">插入的屏障</th><th style="text-align:left;">作用</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>volatile 写</strong></td><td style="text-align:left;">StoreStore + StoreLoad</td><td style="text-align:left;">确保<strong>写前</strong>的所有普通写操作都对其他线程可见；<strong>写后</strong>的指令不会被重排到写之前。</td></tr><tr><td style="text-align:left;"><strong>volatile 读</strong></td><td style="text-align:left;">LoadLoad + LoadStore</td><td style="text-align:left;">确保<strong>读后</strong>的所有读/写操作都不会被重排到读之前。</td></tr></tbody></table><p>正是这些内存屏障，保证了 <code>volatile</code> 的可见性和有序性。</p><h3 id="🌰-volatile的正确使用姿势" tabindex="-1"><a class="header-anchor" href="#🌰-volatile的正确使用姿势"><span>🌰 volatile的正确使用姿势</span></a></h3><p>既然 <code>volatile</code> 不保证原子性，那它有什么用？它最适合用于<strong>状态标志位</strong>。</p><p><strong>✅ 正确示例：优雅地停止线程</strong></p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> MyThread</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> extends</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Thread</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 使用volatile作为状态标志</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    private</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> volatile</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> boolean</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> stopped</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> false</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> run</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">        while</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">!</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">stopped</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 读volatile变量</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">            // ... 执行任务</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> stopThread</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        stopped </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> true</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 写volatile变量</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>为什么这是线程安全的？</strong> 因为对 <code>stopped</code> 的操作是<strong>单一的赋值操作</strong>，本身具有原子性。<code>volatile</code> 在这里保证了当主线程调用 <code>stopThread()</code> 后，工作线程能<strong>立即看到</strong> <code>stopped</code> 变为 <code>true</code>，从而及时退出循环。</p><p><strong>❌ 错误示例：尝试用volatile做计数器</strong></p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Counter</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    private</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> volatile</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> count</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> increment</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        count</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">++</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 这是一个“读-改-写”的复合操作，不是原子操作！</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> getCount</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> return</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> count</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>为什么这是不安全的？</strong><code>count++</code> 实际上包含三个步骤：</p><ol><li>读取 <code>count</code> 的当前值。</li><li>将值加1。</li><li>将新值写回 <code>count</code>。</li></ol><p>假设两个线程同时执行到步骤1，它们可能读到相同的值，比如都是5，然后各自加1后写回，最终结果是6，而不是预期的7。<code>volatile</code> 在这里只能保证它们读到的都是最新值，但无法阻止这两个线程的步骤1-2-3交织在一起执行。</p><h3 id="📌-总结-2" tabindex="-1"><a class="header-anchor" href="#📌-总结-2"><span>📌 总结</span></a></h3><blockquote><p>关于volatile：</p><ol><li><strong>它不是线程安全的</strong>。它只能保证<strong>可见性</strong>和<strong>有序性</strong>，但无法保证复合操作的<strong>原子性</strong>。</li><li>它的底层原理是通过<strong>内存屏障</strong>实现的。在写操作时强制刷盘，在读操作时使缓存失效，并禁止指令重排序。</li><li>它最经典的适用场景是作为一个<strong>状态标志位</strong>，比如安全地停止一个线程。但如果涉及到多个线程对同一个变量进行‘读-改-写’（如i++），则必须使用<code>synchronized</code>或<code>AtomicXXX</code>类。”</li></ol></blockquote><h2 id="线程池核心参数与执行流程" tabindex="-1"><a class="header-anchor" href="#线程池核心参数与执行流程"><span>线程池核心参数与执行流程</span></a></h2><h3 id="🔍-核心参数" tabindex="-1"><a class="header-anchor" href="#🔍-核心参数"><span>🔍 核心参数</span></a></h3><p>线程池通过 <code>ThreadPoolExecutor</code> 的构造函数来定制，必须理解以下7个参数：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> ThreadPoolExecutor</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> corePoolSize</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">      // 1. 核心线程数</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> maximumPoolSize</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">   // 2. 最大线程数</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    long</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> keepAliveTime</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 3. 线程空闲存活时间</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    TimeUnit unit</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">         // 4. 时间单位</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    BlockingQueue</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Runnable</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> workQueue</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 5. 任务队列</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    ThreadFactory threadFactory</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">       // 6. 线程工厂</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    RejectedExecutionHandler handler   </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 7. 拒绝策略</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table><thead><tr><th style="text-align:left;">参数名</th><th style="text-align:left;">作用</th><th style="text-align:left;">比喻与详解</th></tr></thead><tbody><tr><td style="text-align:left;"><strong><code>corePoolSize</code></strong></td><td style="text-align:left;"><strong>核心线程数</strong></td><td style="text-align:left;">公司的<strong>正式员工</strong>。即使空闲，也不会被裁掉（除非设置 <code>allowCoreThreadTimeOut</code>）。</td></tr><tr><td style="text-align:left;"><strong><code>maximumPoolSize</code></strong></td><td style="text-align:left;"><strong>最大线程数</strong></td><td style="text-align:left;">公司<strong>总人力上限</strong>，等于正式工 + 临时工。</td></tr><tr><td style="text-align:left;"><strong><code>keepAliveTime</code></strong></td><td style="text-align:left;"><strong>线程空闲存活时间</strong></td><td style="text-align:left;"><strong>临时工</strong>的合同期。超过这个时间没事干，就会被解雇。</td></tr><tr><td style="text-align:left;"><strong><code>workQueue</code></strong></td><td style="text-align:left;"><strong>任务队列</strong></td><td style="text-align:left;"><strong>待办事项列表</strong>。核心员工都在忙时，新来的任务就排在这里等待。</td></tr><tr><td style="text-align:left;"><strong><code>threadFactory</code></strong></td><td style="text-align:left;"><strong>线程工厂</strong></td><td style="text-align:left;"><strong>HR部门</strong>。负责给新线程（员工）“办入职”，可以统一设置线程名、优先级等。</td></tr><tr><td style="text-align:left;"><strong><code>handler</code></strong></td><td style="text-align:left;"><strong>拒绝策略</strong></td><td style="text-align:left;"><strong>当任务队列和临时工都满员时，HR如何拒绝新任务</strong>。</td></tr></tbody></table><hr><h3 id="👀-任务提交流程" tabindex="-1"><a class="header-anchor" href="#👀-任务提交流程"><span>👀 任务提交流程</span></a></h3><p>当调用 <code>execute(Runnable command)</code> 提交一个任务时，线程池内部遵循一套严格的决策流程。下面的流程图清晰地展示了这一过程，这是理解线程池行为的<strong>灵魂</strong>：</p><!--[--><div class="mermaid-actions"><button class="preview-button" title="preview"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1316 1024" fill="currentColor"><path d="M658.286 0C415.89 0 0 297.106 0 512c0 214.82 415.89 512 658.286 512 242.322 0 658.285-294.839 658.285-512S900.608 0 658.286 0zm0 877.714c-161.573 0-512-221.769-512-365.714 0-144.018 350.427-365.714 512-365.714 161.572 0 512 217.16 512 365.714s-350.428 365.714-512 365.714z"/><path d="M658.286 292.571a219.429 219.429 0 1 0 0 438.858 219.429 219.429 0 0 0 0-438.858zm0 292.572a73.143 73.143 0 1 1 0-146.286 73.143 73.143 0 0 1 0 146.286z"/></svg></button><button class="download-button" title="download"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" fill="currentColor"><path d="M828.976 894.125H190.189c-70.55 0-127.754-57.185-127.754-127.753V606.674c0-17.634 14.31-31.933 31.933-31.933h63.889c17.634 0 31.932 14.299 31.932 31.933v95.822c0 35.282 28.596 63.877 63.877 63.877h511.033c35.281 0 63.877-28.595 63.877-63.877v-95.822c0-17.634 14.298-31.933 31.943-31.933h63.878c17.635 0 31.933 14.299 31.933 31.933v159.7c0 70.566-57.191 127.751-127.754 127.751zM249.939 267.51c12.921-12.92 33.885-12.92 46.807 0l148.97 148.972V94.893c0-17.634 14.302-31.947 31.934-31.947h63.876c17.638 0 31.946 14.313 31.946 31.947v321.589l148.97-148.972c12.922-12.92 33.876-12.92 46.797 0l46.814 46.818c12.922 12.922 12.922 33.874 0 46.807L552.261 624.93c-1.14 1.138-21.664 13.684-42.315 13.693-20.877.01-41.88-12.542-43.021-13.693L203.122 361.135c-12.923-12.934-12.923-33.885 0-46.807l46.817-46.818z"/></svg></button></div><div class="mermaid-wrapper"><div style="display:flex;align-items:center;justify-content:center;height:96px;" class="mermaid-loading"><span style="--loading-icon: url(&quot;data:image/svg+xml;utf8,%3Csvg xmlns=&#39;http://www.w3.org/2000/svg&#39; preserveAspectRatio=&#39;xMidYMid&#39; viewBox=&#39;25 25 50 50&#39;%3E%3CanimateTransform attributeName=&#39;transform&#39; type=&#39;rotate&#39; dur=&#39;2s&#39; keyTimes=&#39;0;1&#39; repeatCount=&#39;indefinite&#39; values=&#39;0;360&#39;%3E%3C/animateTransform%3E%3Ccircle cx=&#39;50&#39; cy=&#39;50&#39; r=&#39;20&#39; fill=&#39;none&#39; stroke=&#39;currentColor&#39; stroke-width=&#39;4&#39; stroke-linecap=&#39;round&#39;%3E%3Canimate attributeName=&#39;stroke-dasharray&#39; dur=&#39;1.5s&#39; keyTimes=&#39;0;0.5;1&#39; repeatCount=&#39;indefinite&#39; values=&#39;1,200;90,200;1,200&#39;%3E%3C/animate%3E%3Canimate attributeName=&#39;stroke-dashoffset&#39; dur=&#39;1.5s&#39; keyTimes=&#39;0;0.5;1&#39; repeatCount=&#39;indefinite&#39; values=&#39;0;-35px;-125px&#39;%3E%3C/animate%3E%3C/circle%3E%3C/svg%3E&quot;);--icon-size: 48px;display: inline-block;width: var(--icon-size);height: var(--icon-size);background-color: currentcolor;-webkit-mask-image: var(--loading-icon);mask-image: var(--loading-icon)"></span></div></div><!--]--><p><strong>流程要点解读：</strong></p><ol><li><strong>核心线程优先</strong>：任务来时，先看能不能用核心线程（正式工）处理。</li><li><strong>队列缓冲</strong>：核心线程忙，<strong>不是立即招临时工</strong>，而是先让任务去排队。</li><li><strong>临时线程扩容</strong>：只有队列也满了，才会创建临时线程（数量不能超过最大线程数）。</li><li><strong>拒绝保护</strong>：队伍排满且人手招满，这时才启动拒绝策略。</li></ol><p><strong>这是一个经典</strong>的“<strong>先核心 -&gt; 再排队 -&gt; 后扩容 -&gt; 最后拒绝</strong>”的保守资源管理策略，能有效防止在高负载下因过度创建线程而崩溃。</p><hr><h3 id="🧀-拒绝策略" tabindex="-1"><a class="header-anchor" href="#🧀-拒绝策略"><span>🧀 拒绝策略</span></a></h3><p>当线程池和队列都满载时（即达到图中最后一步），由拒绝策略决定如何处置新任务。JDK内置了4种策略：</p><table><thead><tr><th style="text-align:left;">策略类</th><th style="text-align:left;">行为</th><th style="text-align:left;">适用场景</th></tr></thead><tbody><tr><td style="text-align:left;"><strong><code>AbortPolicy</code></strong></td><td style="text-align:left;"><strong>直接抛出 <code>RejectedExecutionException</code></strong></td><td style="text-align:left;"><strong>默认策略</strong>。需要明确感知任务被拒绝时使用。</td></tr><tr><td style="text-align:left;"><strong><code>CallerRunsPolicy</code></strong></td><td style="text-align:left;"><strong>让调用者线程自己执行任务</strong></td><td style="text-align:left;">一种负反馈机制，能减缓任务提交速度，并保证任务不丢失。</td></tr><tr><td style="text-align:left;"><strong><code>DiscardPolicy</code></strong></td><td style="text-align:left;"><strong>默默丢弃新任务，不抛异常</strong></td><td style="text-align:left;">可容忍任务丢失的场景（不推荐）。</td></tr><tr><td style="text-align:left;"><strong><code>DiscardOldestPolicy</code></strong></td><td style="text-align:left;"><strong>丢弃队列头部的旧任务，然后重试提交</strong></td><td style="text-align:left;">允许丢弃旧任务，希望处理最新任务的场景。</td></tr></tbody></table><p><strong>自定义拒绝策略</strong>：你也可以实现 <code>RejectedExecutionHandler</code> 接口，将拒绝的任务持久化到数据库或消息队列，等待后续补偿。</p><hr><h3 id="🪤-面试精要与常见坑" tabindex="-1"><a class="header-anchor" href="#🪤-面试精要与常见坑"><span>🪤 面试精要与常见坑</span></a></h3><p><strong>1. 经典面试题：为什么是先入队，而不是先创建最大线程？</strong></p><blockquote><p><strong>答</strong>：这是一种<strong>资源保护</strong>的设计。创建线程是昂贵的操作（涉及系统调用）。队列缓冲能将突发的大量任务平摊到时间线上，利用核心线程逐步消化，避免短时间内创建大量线程耗尽资源。这符合“<strong>池化</strong>”思想的核心——复用与缓冲。</p></blockquote><p><strong>2. 参数设置黄金经验（根据你的业务类型）：</strong></p><ul><li><strong>CPU密集型</strong>（如计算、加密）：<code>corePoolSize</code> ≈ <code>CPU核数</code>。过多线程会导致频繁上下文切换。</li><li><strong>IO密集型</strong>（如网络、DB调用）：<code>corePoolSize</code> ≈ <code>CPU核数 * (1 + IO等待时间/CPU计算时间)</code>。通常可以设大一些，如 <code>2N</code> 到 <code>5N</code>。</li><li><strong>队列选择</strong>： <ul><li><code>LinkedBlockingQueue</code>：无界队列（需警惕内存溢出），适用于任务量平稳、不希望丢弃任务的场景。</li><li><code>ArrayBlockingQueue</code>：有界队列，配合合理的拒绝策略，是<strong>最常用的稳定模式</strong>。</li><li><code>SynchronousQueue</code>：不存储元素的队列，来一个任务就必须立刻有线程处理，适用于低延迟场景。</li></ul></li></ul><p><strong>3. 一个必须避开的坑：</strong> 不要使用 <code>Executors.newFixedThreadPool()</code> 或 <code>newCachedThreadPool()</code> 等工厂方法，因为它们内部使用了<strong>无界队列</strong>或<strong>最大线程数为Integer.MAX_VALUE</strong>，在任务生产速度过快时，极易导致 <strong>OOM</strong>。<strong>务必手动 <code>new ThreadPoolExecutor</code> 并根据业务设置明确的边界。</strong></p><h2 id="什么是阻塞队列-说说常用的阻塞队列有哪些" tabindex="-1"><a class="header-anchor" href="#什么是阻塞队列-说说常用的阻塞队列有哪些"><span>什么是阻塞队列？说说常用的阻塞队列有哪些？</span></a></h2><blockquote><p>阻塞队列 BlockingQueue 继承 Queue ，是我们熟悉的基本数据结构队列的一种特殊类型。</p><p>当从阻塞队列中获取数据时，如果队列为空，则等待直到队列有元素存入。当向阻塞队列中存入元素时，如果队列已满，则等待直到队列中有元素被移除。提供 offer()、put()、take()、poll() 等常用方法。</p></blockquote><p><strong>JDK 提供的阻塞队列的实现有以下几种：</strong></p><ol><li><strong>ArrayBlockingQueue：</strong> 由数组实现的有界阻塞队列，该队列按照 FIFO 对元素进行排序。维护两个整形变量，标识队列头尾在数组中的位置，在生产者放入和消费者获取数据共用一个锁对象，意味着两者无法真正的并行运行，性能较低。</li><li><strong>LinkedBlockingQueue：</strong> 由链表组成的有界阻塞队列，如果不指定大小，默认使用 Integer.MAX_VALUE 作为队列大小，该队列按照 FIFO 对元素进行排序，对生产者和消费者分别维护了独立的锁来控制数据同步，意味着该队列有着更高的并发性能。</li><li><strong>SynchronousQueue：</strong> 不存储元素的阻塞队列，无容量，可以设置公平或非公平模式，插入操作必须等待获取操作移除元素，反之亦然。</li><li><strong>PriorityBlockingQueue：</strong> 支持优先级排序的无界阻塞队列，默认情况下根据自然序排序，也可以指定 Comparator</li><li><strong>DelayQueue：</strong> 支持延时获取元素的无界阻塞队列，创建元素时可以指定多久之后才能从队列中获取元素，常用于缓存系统或定时任务调度系统。</li><li><strong>LinkedTransferQueue：</strong> 一个由链表结构组成的无界阻塞队列，与 LinkedBlockingQueue 相比多了 transfer 和 tryTranfer 方法，该方法在有消费者等待接收元素时会立即将元素传递给消费者。</li><li><strong>LinkedBlockingDeque：</strong> 一个由链表结构组成的双端阻塞队列，可以从队列的两端插入和删除元素</li></ol><h2 id="介绍什么是threadlocal-以及为什么会有内存泄露风险" tabindex="-1"><a class="header-anchor" href="#介绍什么是threadlocal-以及为什么会有内存泄露风险"><span>介绍什么是ThreadLocal，以及为什么会有内存泄露风险</span></a></h2><h3 id="🔍-threadlocal介绍" tabindex="-1"><a class="header-anchor" href="#🔍-threadlocal介绍"><span>🔍 ThreadLocal介绍</span></a></h3><p>为了解决“在多线程下访问共享变量时，存在的并发问题”，我们可以使用同步机制（如: <code>synchronized</code>）, 同时也可以使用<code>ThreadLocal</code>。<code>ThreadLocal</code> 提供了一个“每个线程都有自己的专属变量”的机制，避免了多线程环境下共享变量的并发问题。通过<code>ThreadLocal</code>的<code>set</code>方法可以看出来。<code>ThreadLocal</code>通过<code>Map</code>结构来存储数据，Key就是当前线程，Value就是存储的数据。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> set</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">T value</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    Thread</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> t</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> Thread</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">currentThread</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    ThreadLocalMap</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> map</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> getMap</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">t</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">map </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">!=</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> null</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">        map</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">set</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> value</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> else</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">        createMap</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">t</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> value</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基本用法如下：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> ThreadLocalExample</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 存储用户信息</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    private</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> static</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> final</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ThreadLocal</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">User</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> CURRENT_USER</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ThreadLocal</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;&gt;();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> setCurrentUser</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">User </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">user</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">        CURRENT_USER</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">set</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">user</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 将用户信息绑定到当前线程</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    public</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> User </span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">getCurrentUser</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">        return</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> CURRENT_USER</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">get</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 从当前线程获取用户信息</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> clearCurrentUser</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">        CURRENT_USER</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">remove</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 重要！使用完后清理，防止内存泄漏</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="🤔-为什么存在内存泄露-memory-leak-风险" tabindex="-1"><a class="header-anchor" href="#🤔-为什么存在内存泄露-memory-leak-风险"><span>🤔 为什么存在内存泄露（Memory Leak）风险</span></a></h3><p>这就要理解上文提到的<code>ThreadLocal</code>使用的<code>Map</code>结构了，源码如下：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">static</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> ThreadLocalMap</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">  static</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Entry</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> extends</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> WeakReference</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">ThreadLocal</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">?</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;&gt;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">        /** The value associated with this ThreadLocal. */</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        Object</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> value</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 注意这里的value依然是强引用</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">        Entry</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">ThreadLocal</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">?</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> k</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> Object </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">v</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">            super</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">k</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">            value </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> v</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ThreadLocalMap 中的 Entry：</p><ul><li><strong>Key：</strong> 是一个弱引用，指向 threadLocal 实例。</li><li><strong>Value：</strong> 是一个强引用，指向设置的数据实例。</li></ul><blockquote><p>想了解强引用和弱引用，可以参考<a class="vp-link link" href="/java-guide/hg5e8awy/"><!--[--> Java基础<!--]--><!----></a> 中“什么是强引用、软引用、弱引用、虚引用”相关内容。</p></blockquote><p>当程序使用完<code>ThreadLocal</code>并且正确释放(例如调用<code>remove()</code>方法)，是不会出现内存泄露风险的。但是如果创建 ThreadLocal 的强引用一直存在，或者线程迟迟不结束（例如使用线程池，线程会复用且长期存活），那么弱引用就失去了其加速回收的关键作用。</p><p>此时：引用链变成了一个强引用链，导致无法回收：</p><blockquote><p>Thread A (强引用) -&gt; ThreadA.threadLocals (强引用) -&gt; Entry (强引用) -&gt; Entry.value (强引用) -&gt; 数据实例</p></blockquote><p>即使你的业务代码已经不再需要这个 数据实例，但由于这条强引用链的存在，只要线程 ThreadA 依然存在，这个 数据实例 就会一直驻留在内存中，造成内存泄露。如果线程池中每个线程都这么存一个大数据对象，最终可能导致 OutOfMemoryError。</p><p><strong>所以存在内存泄露风险的原因是：</strong></p><ol><li><code>ThreadLocalMap</code> 的Entry中，Key是弱引用，但Value是强引用</li><li>线程生命周期过长，导致强引用一致存在，无法被GC回收</li><li>未及时调用<code>remove()</code>方法</li></ol></div><!----><!----><!----></div></main><footer class="vp-doc-footer" data-v-79596a8a data-v-132f89cc><!--[--><!--]--><!----><div class="contributors" aria-label="Contributors" data-v-132f89cc><span class="contributors-label" data-v-132f89cc>贡献者: </span><span class="contributors-info" data-v-132f89cc><!--[--><!--[--><span class="contributor" data-v-132f89cc>lvmengtian</span><!----><!--]--><!--]--></span></div><nav class="prev-next" data-v-132f89cc><div class="pager" data-v-132f89cc><a class="vp-link link pager-link prev" href="/java-guide/h9mgtev9/" data-v-132f89cc><!--[--><span class="desc" data-v-132f89cc>上一页</span><span class="title" data-v-132f89cc>Java 集合</span><!--]--><!----></a></div><div class="pager" data-v-132f89cc><a class="vp-link link pager-link next" href="/java-guide/ypjcijom/" data-v-132f89cc><!--[--><span class="desc" data-v-132f89cc>下一页</span><span class="title" data-v-132f89cc>Java 虚拟机</span><!--]--><!----></a></div></nav></footer><!----><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!--]--><button type="button" class="vp-back-to-top" aria-label="back to top" data-v-e1dbaae2 style="display:none;" data-v-64659f34><span class="percent" data-allow-mismatch data-v-64659f34>0%</span><span class="show icon vpi-back-to-top" data-v-64659f34></span><svg aria-hidden="true" data-v-64659f34><circle cx="50%" cy="50%" data-allow-mismatch style="stroke-dasharray:calc(0% - 12.566370614359172px) calc(314.1592653589793% - 12.566370614359172px);" data-v-64659f34></circle></svg></button><footer class="vp-footer has-sidebar" vp-footer data-v-e1dbaae2 data-v-cbcd6b75><!--[--><div class="container" data-v-cbcd6b75><p class="message" data-v-cbcd6b75>Powered by <a target="_blank" href="https://v2.vuepress.vuejs.org/">VuePress</a> & <a target="_blank" href="https://theme-plume.vuejs.press">vuepress-theme-plume</a></p><!----></div><!--]--></footer><!--[--><!--]--><!--]--></div><!----><!--]--><!--[--><!--]--><!--]--></div><script type="module" src="/assets/app-DqL0oT9G.js" defer></script></body></html>