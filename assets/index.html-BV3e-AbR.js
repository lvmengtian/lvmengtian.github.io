import{_ as e,c as l,a as i,d as n,e as t,b as r,w as p,r as h,o as g}from"./app-DqL0oT9G.js";const d="/images/spring_third_cache.png",k={};function o(c,s){const a=h("font");return g(),l("div",null,[s[2]||(s[2]=i('<h2 id="spring如何解决循环依赖" tabindex="-1"><a class="header-anchor" href="#spring如何解决循环依赖"><span>Spring如何解决循环依赖</span></a></h2><blockquote><p>“在Spring的世界里，Bean就像一群需要互相协作的同事。但有时会出现一种尴尬的局面：</p><ul><li>A同事说：‘不行，我得等B把方案给我，我才能开始工作。’</li><li>B同事说：‘不行，我得等A把资料给我，我才能动工。’</li></ul><p>这就形成了 <strong>‘循环依赖’</strong>。在Spring中，如果两个Bean（如A和B）互相依赖（A依赖B，B也依赖A），Spring是如何处理，而不让整个应用启动失败的呢？今天小毛带你深入三级缓存，看看Spring的神来之笔。”</p></blockquote><h3 id="🤔-循环依赖会报错吗" tabindex="-1"><a class="header-anchor" href="#🤔-循环依赖会报错吗"><span>🤔 <strong>循环依赖会报错吗？</strong></span></a></h3><p><strong>结论是：不一定，分情况讨论。</strong></p><ol><li><strong>大部分情况下，不报错</strong>：Spring框架<strong>内置了一套成熟的机制（三级缓存）</strong> 来解决常见的循环依赖问题。</li><li><strong>特定情况下，会报错</strong>：如果Spring无法解决，它会抛出 <code>BeanCurrentlyInCreationException</code> 异常。</li></ol>',5)),n("p",null,[n("strong",null,[s[1]||(s[1]=t("关键在于：",-1)),r(a,{color:"red"},{default:p(()=>[...s[0]||(s[0]=[t("依赖的方式和Bean的作用域。",-1)])]),_:1})])]),s[3]||(s[3]=i('<h3 id="📚-spring的解决方案-三级缓存架构" tabindex="-1"><a class="header-anchor" href="#📚-spring的解决方案-三级缓存架构"><span>📚 <strong>Spring的解决方案：三级缓存架构</strong></span></a></h3><p>我们先来理解Spring为解决循环依赖准备的“三级仓库”：</p><table><thead><tr><th style="text-align:left;">缓存名称</th><th style="text-align:left;">源码中名称</th><th style="text-align:left;">存储内容</th><th style="text-align:left;">作用</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>一级缓存 (单例池)</strong></td><td style="text-align:left;"><code>singletonObjects</code></td><td style="text-align:left;"><strong>完整的单例Bean</strong></td><td style="text-align:left;">存放已经完全初始化好的Bean，对外提供使用。</td></tr><tr><td style="text-align:left;"><strong>二级缓存 (早期曝光)</strong></td><td style="text-align:left;"><code>earlySingletonObjects</code></td><td style="text-align:left;"><strong>早期的Bean对象</strong> (尚未填充属性)</td><td style="text-align:left;">存放刚从三级缓存中取出的对象，避免代理对象被重复创建。</td></tr><tr><td style="text-align:left;"><strong>三级缓存 (对象工厂)</strong></td><td style="text-align:left;"><code>singletonFactories</code></td><td style="text-align:left;"><strong>ObjectFactory</strong> (用于生成早期对象的工厂)</td><td style="text-align:left;"><strong>解决循环依赖的关键</strong>，存放一个能生成早期Bean引用（可能是代理对象）的工厂。</td></tr></tbody></table><h3 id="🔍-解决流程详解" tabindex="-1"><a class="header-anchor" href="#🔍-解决流程详解"><span>🔍 <strong>解决流程详解</strong></span></a></h3><p>让我们以经典的属性注入循环依赖 <code>A -&gt; B -&gt; A</code> 为例，来看Spring如何通过三级缓存破解这个“死结”： <img src="'+d+`" alt=""></p><p><strong>流程核心要点：</strong></p><ol><li><strong>破局点在于“实例化”和“依赖注入”的分离</strong>：Spring先把Bean的“空壳”（对象实例）创建出来，并不等它完全填满属性，就提前把这个“空壳”的引用暴露出去。</li><li><strong>三级缓存是核心</strong>：它存放的是一个工厂。这个工厂的最大作用是<strong>在需要的时候能够返回一个早期引用，并且能处理AOP代理问题</strong>。如果直接把这个早期引用放在二级缓存，那么遇到AOP时，就无法保证返回的是同一个代理对象。</li><li><strong>升级缓存</strong>：当某个Bean的早期引用被其他Bean依赖后，它会被从三级缓存升级到二级缓存。</li></ol><h3 id="🌰-无法解决的循环依赖场景" tabindex="-1"><a class="header-anchor" href="#🌰-无法解决的循环依赖场景"><span>🌰 <strong>无法解决的循环依赖场景</strong></span></a></h3><p>Spring不是万能的，在以下情况下，循环依赖会<strong>报错</strong>：</p><ol><li><p><strong>构造器循环依赖</strong>：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">@</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">Service</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> A</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    private</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> B</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> b</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    public</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> A</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">B </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">b</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 通过构造器注入B</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">        this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">b</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> b</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">@</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">Service</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> B</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    private</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> A</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> a</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    public</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> B</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">A </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">a</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 通过构造器注入A</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">        this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">a</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> a</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>原因</strong>：在实例化A的时候，就需要一个完整的B；而实例化B又需要一个完整的A。双方连“空壳”都创建不出来，死锁无法破解。</p></li><li><p><strong>Prototype作用域的Bean循环依赖</strong>： <strong>原因</strong>：Spring不缓存Prototype类型的Bean，所以无法提供早期暴露的引用。</p></li><li><p><strong>@Async方法导致的循环依赖</strong>等特殊情况。</p></li></ol>`,10))])}const B=e(k,[["render",o]]),A=JSON.parse('{"path":"/java-guide/ysb3pgbj/","title":"Spring","lang":"zh-CN","frontmatter":{"title":"Spring","createTime":"2025/11/28 17:10:04","permalink":"/java-guide/ysb3pgbj/"},"readingTime":{"minutes":2.88,"words":864},"git":{"createdTime":1764322838000,"updatedTime":1765456266000,"contributors":[{"name":"lvmengtian","username":"lvmengtian","email":"lvmengtian@xiaohongshu.com","commits":4,"avatar":"https://avatars.githubusercontent.com/lvmengtian?v=4","url":"https://github.com/lvmengtian"}]},"filePathRelative":"notes/java-guide/Spring/spring.md","headers":[]}');export{B as comp,A as data};
